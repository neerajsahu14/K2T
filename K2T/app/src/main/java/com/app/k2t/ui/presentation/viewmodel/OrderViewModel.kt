package com.app.k2t.ui.presentation.viewmodel

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.app.k2t.firebase.repositoryimpl.OrderRepositoryImpl
import com.app.k2t.firebase.model.OrderItem
import com.app.k2t.firebase.model.Order
import com.app.k2t.firebase.utils.OrderStatus
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch
import org.koin.core.component.KoinComponent
import org.koin.core.component.inject
import java.util.Date
import java.util.UUID
import kotlin.getValue

class OrderViewModel : ViewModel(), KoinComponent {
    private val cartViewModel : CartViewModel by inject()
    private val orderRepository: OrderRepositoryImpl by inject()

    private val orderItemViewModel : OrderItemViewModel by inject()

    private val userViewModel : UserViewModel  by inject()
    // private val tableID = userViewModel.user.value?.tableId // Use tableId from function parameter

    private val _orderPlacementState = MutableStateFlow<OrderPlacementStatus>(OrderPlacementStatus.Idle)
    val orderPlacementState: StateFlow<OrderPlacementStatus> = _orderPlacementState.asStateFlow()

    private val _activeOrdersForTable = MutableStateFlow<List<Order>>(emptyList())
    val activeOrdersForTable: StateFlow<List<Order>> = _activeOrdersForTable.asStateFlow()

    sealed class OrderPlacementStatus {
        object Idle : OrderPlacementStatus()
        object Processing : OrderPlacementStatus()
        object PaymentSuccess : OrderPlacementStatus()
        data class OrderPlaced(val orderId: String) : OrderPlacementStatus()
        data class Error(val message: String) : OrderPlacementStatus()
    }


    fun placeOrder(
        tableId: String, // Make tableId nullable if it can be absent
        tableNumber: String, // Make tableNumber nullable
        // onPaymentSuccess: () -> Unit, // Handled by state
        // onOrderPlaced: (orderId: String) -> Unit, // Handled by state
        // onError: (String) -> Unit // Handled by state
    ) {
        viewModelScope.launch {
            _orderPlacementState.value = OrderPlacementStatus.Processing
            try {
                // Step 1: Fetch all items from the cart
                val cartItems = cartViewModel.allFoodInCart.value

                if (cartItems.isEmpty()) {
                    _orderPlacementState.value = OrderPlacementStatus.Error("Cart is empty!")
                    return@launch
                }

                // Step 2: Convert cart items to OrderItems and save them
                val orderItemModels = mutableListOf<OrderItem>()
                cartItems.forEach { foodInCart ->
                    val orderItem = OrderItem(
                        itemId = UUID.randomUUID().toString(), // Generate unique ID for each item
                        foodId = foodInCart.foodId,
                        foodName = foodInCart.foodName,
                        quantity = foodInCart.quantity,
                        unitPrice = foodInCart.unitPrice,
                        totalPrice = foodInCart.totalPrice,
                        tableNumber = tableNumber,
                        tableId = tableId,
                        statusCode = OrderStatus.PENDING.code,
                        addedAt = Date(),
                        orderId = null // orderId will be updated later
                    )
                    orderItemViewModel.createOrderItem(orderItem) // Save to Firestore
                    orderItemModels.add(orderItem)
                }

                // Step 3: Calculate order totals
                val subTotal = orderItemModels.sumOf { it.totalPrice ?: 0.0 }
                // These can be more dynamic or configurable
                val taxRate = 0.10 // 10%
                val tipRate = 0.05  // 5%
                val tax = subTotal * taxRate
                val tip = subTotal * tipRate
                val totalPrice = subTotal + tax + tip

                // Step 4: Create an Order object (without orderId yet)
                val newOrder = Order(
                    // orderId will be generated by Firestore
                    orderItemIds = orderItemModels.mapNotNull { it.itemId },
                    subTotal = subTotal,
                    tax = tax,
                    tip = tip,
                    totalPrice = totalPrice,
                    tableID = tableId, // Use tableId from parameter
                    tableNumber = tableNumber,
                    createdAt = Date(),
                    statusCode = OrderStatus.IN_PROGRESS.code,
                    // transactionId can be set after actual payment
                )

                // Step 5: Simulate payment success
                // In a real app, integrate with a payment gateway here.
                // For now, we assume payment is successful.
                _orderPlacementState.value = OrderPlacementStatus.PaymentSuccess
                // onPaymentSuccess() // Callback handled by state

                // Step 6: Save the order to Firebase and get the generated orderId
                orderRepository.createOrder(newOrder).addOnSuccessListener { generatedOrderId ->
                    viewModelScope.launch {
                        // Step 7: Update all OrderItems with the generatedOrderId
                        orderItemModels.forEach { orderItem ->
                            orderItem.itemId?.let { itemId ->
                                orderItemViewModel.updateOrderItemWithOrderId(itemId,
                                    generatedOrderId.toString()
                                )
                            }
                        }

                        // Step 8: Clear the cart
                        cartViewModel.clearCart()
                        _orderPlacementState.value = OrderPlacementStatus.OrderPlaced(
                            generatedOrderId.toString()
                        )
                        // onOrderPlaced(generatedOrderId) // Callback handled by state
                    }
                }.addOnFailureListener { exception ->
                    _orderPlacementState.value = OrderPlacementStatus.Error("Failed to place order: ${exception.message}")
                    // onError("Failed to place order: ${exception.message}") // Callback handled by state
                }
            } catch (e: Exception) {
                _orderPlacementState.value = OrderPlacementStatus.Error("An error occurred: ${e.message}")
                // onError("An error occurred: ${e.message}") // Callback handled by state
            }
        }
    }

    fun getActiveOrdersForTable(tableId: String) {
        viewModelScope.launch {
            orderRepository.getActiveOrdersForTable(tableId).collect { orders ->
                _activeOrdersForTable.value = orders
            }
        }
    }

    fun getOderById(id: String) {

    }
    fun resetOrderPlacementStatus() {
        _orderPlacementState.value = OrderPlacementStatus.Idle
    }
}